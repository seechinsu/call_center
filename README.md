# call_center
sample scala (microservice)

A simple demonstration of Microservices in Scala. 

### Features:
 - CRUD API (Completed and ready for on prem release)
 - Worker (Completed and ready for on prem release)
 - Search (Completed and ready for on prem release)
 - ETL (Future thinking - POC)
 - Report (Future thinking - POC)
 - service registry and service discrovery via consul or client sdk (TBD)
 - JWT Based API Gateway via Kong or Nginx (TBD)

![Alt](images/image.png "Scala Microservices")
 
Introduction
------------
In this project I  have mainly focused on **CRUD** and **Search**, because I believe it's a common in most microservices pattern.
 
To scale up the project we have to run multiple instances of a certain service to balance the load.
Each service runs completely isolated, but in some cases they need to communicate with each other.

This projects consists of three main microservices:
 - Api-service:  This service is responsible for writes/reads out of mongo (a document oriented datastore) as well as eventing out to kafka (a broker engine for your event stream).
 - worker-service: This service allows consumers to read off the event stream and update the solr search store accordingly
 - search-service: This service allows for a client to broker reads to solr 

## CRUD

When you break down your monolithic application to several focused microservices, you will have to find an efficient way to locate your services; moreover, services will have to communicate with each other. That is exactly what restful api(s) and kafka events are all about.
 


## Search
A read only instance of your data optimized with indexes based on your search criteria.

Requirements
------------

* JDK 8 (e.g. [http://www.oracle.com/technetwork/java/javase/downloads/index.html](http://www.oracle.com/technetwork/java/javase/downloads/index.html));
* sbt ([http://www.scala-sbt.org/release/docs/Getting-Started/Setup.html](http://www.scala-sbt.org/release/docs/Getting-Started/Setup.html));
* Solr
* Docker
* Docker-compose
* Kafka
* MongoDb

### Run in Docker

For launching application in Docker, you must configure database docker instance and run docker image, generated by sbt.

Generating application docker image and publishing on localhost:
```bash
sbt docker:publishLocal
```

Pulling *mongo* dokcer image from [https://hub.docker.com/_/mongo/](https://hub.docker.com/_/mongo/):
```bash
docker pull mongo
```

Pulling *kafka* docker image from [https://hub.docker.com/_/kafka/](https://hub.docker.com/_/kafka/)
```bash
docker pull kafka
```

Pulling *solr* docker image from [https://hub.docker.com/_/solr/](https://hub.docker.com/_/solr/)
```bash
docker pull solr
```

Starting microservices and binding all stuff together:
```bash
$ cd deploy
$ docker-compose up
```

It usually takes a few seconds to register all the services in Consul. You can verify that all your services have been successfully registered on Consul by viewing the services from the Consul UI at [http://localhost:8500](http://localhost:8500).

After all your services are registered, we are ready to test our load balancer. Open up a new terminal session and issue the following cURL commands:

**Register a Case**

```bash
curl -X POST \
  http://localhost:9000/case \
  -H 'content-type: application/json' \
  -d '{
}'
```

**Search for a case**
```bash
curl -X POST \
  http://localhost:9002/search/case \
  -H 'content-type: application/json' \
  -d '{
}'
```

Stopping and removing containers:
```bash
$ docker-compose stop
$ docker-compose rm
```


